// Need these to function with client and db
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

//-------------------------------------------------------------------------------------------------//
//-------------------------------------------------------------------------------------------------//
// employee account permission provide the correct view of the product!
// this enum represents all the role levels in order to maintain a hiearchy of 
// employee -> floorman -> siteManger -> SuperManager -> Admin -> SuperAdmin
//-------------------------------------------------------------------------------------------------//
// USER: Base level operation to the app can only Read, and write over files 
// but can not edit stored data
//-------------------------------------------------------------------------------------------------//
// MANAGERS: given to trustworthy individuals that lead teams. They have access
// to team submitted records and can alter them before submitting them to the office,
// they also have access to QR generation to clock in and get team clocked in if a 
//  qrcode was missing. 
// Provides the answer to the question what do I do If I have no QR code on me?
//-------------------------------------------------------------------------------------------------//
// ADMIN: Given to people that need full access to certain items but not sensitive data
// can view the app as a dashboard, see all projects underneath their supervision and lastly 
// they can use also export data via CSV files
// Later developments: include Looking at desired staticstics and creation and modification of forms 
//-------------------------------------------------------------------------------------------------//

//SUPER ADMIN: Given All privelages and rights to change data and update things in the database. 
//-------------------------------------------------------------------------------------------------//
//-------------------------------------------------------------------------------------------------//
enum permission {
  USER
  MANAGER
  ADMIN
  SUPERADMIN
}

//-------------------------------------------------------------------------------------------------//
// Truck You see a Truck Manger widget
// Tasco sees Tasco manager widget
// Base sees general widgets
//-------------------------------------------------------------------------------------------------//
enum formStatus {
  PENDING
  APPROVED
  DENIED
}

enum tags {
  Truck
  Trailer
  Equipment
}

//-------------------------------------------------------------------------------------------------//
model User {
  id                  String    @id @default(cuid())
  firstName           String
  lastName            String
  username            String    @unique
  password            String
  truck_view          Boolean?
  tasco_view          Boolean?
  labor_view          Boolean?
  mechanic_view       Boolean?
  email               String    @unique
  emailVerified       DateTime? @map("email_verified")
  phone               String
  image               String?
  accounts            Account[]
  sessions            Session[]
  employee_id         Int?
  Employee            Employee? @relation(fields: [employee_id], references: [employee_id])

  @@map("users")
}

model Account {
  userId            String
  employee_id       Int      @unique
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  employee          Employee @relation(fields: [employee_id], references: [employee_id])
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

//-------------------------------------------------------------------------------------------------//
// employee model of what data/information he would hold
// why is this needed for the app/ it is needed as the central information hub of the relational database
// the employee is link to what crew they are apart of, their time card, their account, the equipment they log
// the position title they have in a company and their contact information, and address to send check to
// with out this table the app wouldnt work.
model Employee {
  employee_id               Int                    @id @default(autoincrement())
  employee_first_name       String
  employee_middle_name      String?
  employee_last_name        String
  employee_dob              DateTime
  employee_start_date       DateTime? //set null for people who dont remember start date
  employee_termination_date DateTime?
  employee_availability     String
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  crewMembers               CrewMember[]
  timeRequestForms          FormData[]
  timeSheet                 TimeSheet[]
  employeeEquipmentLogs     EmployeeEquipmentLog[]
  employeePositions         EmployeePosition[]
  contacts                  ContactJoin[]
  addresses                 AddressAssigner[]
  users                     User[]
  costcodeJobsite           CostCodeJobsite[]
  Account                   Account?
}

//----------------------------------------------------------------------------------------------------------------------//
// Jobbsite section
// What problem does this solve?
// This table creates or allows creations of jobsite, allows the company to pair costcodes with jobsites
// to lower the amount of effort it tkes to find each costcode. tells the company when they started / created
// created the project and enables a way to save an address to a site, and assign a team to a jobsite. A
// project manager will be able to view everyone that is assigned to his site rather then a personal team. 
//----------------------------------------------------------------------------------------------------------------------//
model Jobsite {
  jobsite_id            Int                    @id @default(autoincrement())
  qr_id                 String                 @unique
  jobsite_name          String
  jobsite_active        Boolean                @default(true)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  costCodeJobsites      CostCodeJobsite[]
  addresses             AddressAssigner[]
  employeeEquipmentLogs EmployeeEquipmentLog[]
  jobsites              CrewJobsite[]
}

//----------------------------------------------------------------------------------------------------------------------//
// the app would need a function a prisma call to call all timesheets by employee_id, 
// filtering down by pay period, and then buy day for that pay period
//
// this database then will be exported and is designed to be almost one to one with the accounting software. 
// accounting software is 
// |submitDate | Form Id | empl ID| Date| ProfitID(jobsite)|
// | CostCode| NU | FP| Start Time| END Time| Job Description | Duration |

model TimeSheet {
  submit_date           DateTime @default(now())
  form_id               Int      @id @default(autoincrement()) //in viewpoint this tracks the time form to come in, driver, tasco, and regular
  employee_id           Int
  date                  DateTime @default(now())
  jobsite_id            Int
  costcode              String
  nu                    String   @default("nu") // non union {} default
  Fp                    String?  @default("fp") // field personal
  vehicle_id            Int?
  start_time            DateTime
  end_time              DateTime
  total_break_time      Float?
  duration              Float
  starting_mileage      Int?
  ending_mileage        Int?
  left_idaho            Boolean? @default(false)
  equipment_hauled      String?
  materials_hauled      String?
  hauled_loads_quantity Int?
  refueling_gallons     Int?
  timesheet_comments    String?
  app_comment           String? //this is a backend ai we want to develope to do filtered comments
  employee              Employee @relation(fields: [employee_id], references: [employee_id])
}

//----------------------------------------------------------------------------------------------------------------------//
// what does having a seperate vehicle table do? It allows us as a compny to make a vehicle QrID unique for the qrcode to scan
// it provides a way to log a vehicle under equipment log
// in this log we enable the employee to record what there equipment is doing and how well it is.
// eventually we want the employee to be able to update the status of the equipment or rather report a 
// broken asset  that will be submitted via a form to the office to handle the fixing procedure. 
// this also share with jobsite the equipment and the time it was used 
//----------------------------------------------------------------------------------------------------------------------//
model EmployeeEquipmentLog {
  employee_equipment_log_id Int        @id @default(autoincrement())
  equipment_id              Int
  jobsite_id                Int
  employee_id               Int
  start_time                DateTime
  end_time                  DateTime
  equipment_notes           String
  equipment_status          String     @default("Operational")
  createdAt                 DateTime   @default(now())
  updatedAt                 DateTime   @updatedAt
  employee                  Employee   @relation(fields: [employee_id], references: [employee_id])
  Job                       Jobsite    @relation(fields: [jobsite_id], references: [jobsite_id])
  Equipment                 Equipment? @relation(fields: [equipment_id], references: [equipment_id])
}

//----------------------------------------------------------------------------------------------------------------------//
//must have a unique QR for equipment status to be applied
//do we need to limit scanned equipment?  equipmentStatus 
// designed to help filter equipment by page rendering -> equipment_tag
// isvehicle and is trailer will allow the qrcode to work
// added a tag section to prevent creation of a new category so the tags above have that equipment
// included ways to monitor equipment and in the future we can work towards notifications on when to service them
// and when something will expire to keep up to date on our equipment
//----------------------------------------------------------------------------------------------------------------------//
model Equipment {
  equipment_id          Int                    @id @default(autoincrement())
  is_vehicle            Boolean
  is_trailer            Boolean
  qr_id                 String                 @unique
  name                  String
  description           String
  status                Boolean
  equipment_tag         tags
  last_inspection       DateTime?
  last_repair           DateTime?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  make                  String?
  model                 String?
  year                  String?
  license_plate         String?
  is_registered         DateTime?
  mileage               Int?
  is_active             Boolean                @default(true)
  employeeEquipmentLogs EmployeeEquipmentLog[]
}

//----------------------------------------------------------------------------------------------------------------------//
// this sections links with the site and will ultimately export all its site data to the time card app
//provides a relationship with jobsites and costcodes cost codes to a jobsite are one to one due to the method we will use of 
//jobsites however have many costcodes
model CostCodeJobsite {
  cost_code_jobsite_id Int      @id @default(autoincrement())
  jobsite_id           Int
  cost_code_id         Int
  employee_id          Int
  start_time           DateTime
  end_time             DateTime
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  employee Employee @relation(fields: [employee_id], references: [employee_id])
  jobsite  Jobsite  @relation(fields: [jobsite_id], references: [jobsite_id])
  costCode CostCode @relation(fields: [cost_code_id], references: [cost_code_id])
}

// provide a seperate method to record a cost code and eventually assign it to a jobsite
model CostCode {
  cost_code_id          Int               @id @default(autoincrement())
  cost_code             String
  cost_code_description String
  cost_code_type        String
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @default(now()) @updatedAt
  CostCodeJobsite       CostCodeJobsite[]
}

//----------------------------------------------------------------------------------------------------------------------//
// crew data for seeing the entire crew and enabling site linking it also has direct access to the employeed time cards, and some desire profile settings
model CrewMember {
  crew_member_id Int      @id @default(autoincrement())
  employee_id    Int
  crew_id        Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  employee       Employee @relation(fields: [employee_id], references: [employee_id])
  crew           Crew     @relation(fields: [crew_id], references: [crew_id])
}

// the crew model assigns member to a crew, it also reports  
model Crew {
  crew_id          Int           @id @default(autoincrement())
  crew_name        String
  crew_description String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  crewMembers      CrewMember[]
  jobsites         CrewJobsite[]
}

// provides a unique many to many relationship to the crew and jobsites they also can only have one unique connection vis the 
// @unique variable preventing duplication
// we want this relation ship so that project managers can see the full teams of people for his site. 
model CrewJobsite {
  crewJobsite_id Int      @id @default(autoincrement())
  crew_id        Int
  jobsite_id     Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  crew           Crew     @relation(fields: [crew_id], references: [crew_id])
  jobsite        Jobsite  @relation(fields: [jobsite_id], references: [jobsite_id])

  @@unique([crew_id, jobsite_id])
}

//----------------------------------------------------------------------------------------------------------------------//
// employee positions
model EmployeePosition {
  employee_positions_id Int      @id @default(autoincrement())
  employee_id           Int
  position_id           Int
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  employee              Employee @relation(fields: [employee_id], references: [employee_id])
  role                  Position @relation(fields: [position_id], references: [position_id])

  @@unique([position_id, employee_id])
}

model Position {
  position_id       Int                @id @default(autoincrement())
  position_name     String             @unique
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  employeePositions EmployeePosition[]
}

//----------------------------------------------------------------------------------------------------------------------//

//----------------------------------------------------------------------------------------------------------------------//
//phone number models

model Contact {
  contact_id           Int           @id @default(autoincrement())
  phone_number         String?
  email                String
  emergency_contact    String
  emergency_contact_no String
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  contactJoin          ContactJoin[]
}

model ContactJoin {
  contact_join_id Int      @id @default(autoincrement())
  contact_id      Int
  employee_id     Int
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  contact         Contact  @relation(fields: [contact_id], references: [contact_id])
  employee        Employee @relation(fields: [employee_id], references: [employee_id])
}

//----------------------------------------------------------------------------------------------------------------------//
// Address Assigner makes a many to many relation ship from employees to there address

model AddressAssigner {
  address_assigner_id Int       @id @default(autoincrement())
  address_id          Int
  employee_id         Int?
  jobsite_id          Int?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  address             Address   @relation(fields: [address_id], references: [address_id])
  employee            Employee? @relation(fields: [employee_id], references: [employee_id])
  jobsite             Jobsite?  @relation(fields: [jobsite_id], references: [jobsite_id])

  @@unique([employee_id, jobsite_id])
}

// the purpose of the address table is to hold all addresses of sites, employees, and other data necessary for app,
// potetially using geolocation to access sites down the line. 
model Address {
  address_id  Int               @id @default(autoincrement())
  street_no   Int
  street_name String
  city        String
  state       String
  zipcode     Int
  country     String
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  addresses   AddressAssigner[]
}

//----------------------------------------------------------------------------------------------------------------------//

//----------------------------------------------------------------------------------------------------------------------//
// one form in our db part of settings
model FormData {
  form_id               Int        @id @default(autoincrement())
  form_type             String
  form_name             String
  employee_id           Int
  start_date_requested  DateTime
  end_date_requested    DateTime
  time_request_type     String
  time_request_comments String
  createdAt             DateTime   @default(now())
  updatedAt             DateTime   @updatedAt
  status                formStatus @default(PENDING)
  employee              Employee   @relation(fields: [employee_id], references: [employee_id])
}
